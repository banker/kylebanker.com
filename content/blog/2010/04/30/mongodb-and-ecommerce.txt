--- 
title:      MongoDB and E-commerce
desc:       description
keywords:   keywords
created_at: 2010-04-30 13:20:45.692078 -04:00
blog_post:  true
layout: blog
filter:
- erb
- textile
--- 

There are still a number of misconceptions regarding MongoDB's
suitability for <nobr>e-commerce</nobr> sites. This is understandable, as most of the databases
falling under the NoSQL umbrella would fare poorly in an e-commerce setting.
But this is not the case with MongoDB. Indeed, with its support for rich data models,
dynamic, indexed queries, and atomic operations, MongoDB is a viable and even
desirable database for e-commerce; here's why.

h2. <strong>Catalog Management</strong>

If you need some insight into the ways in which catalog management is handled
with relational databases, have a quick look at the schemas of the popular
"Magento e-commerce framework":http://www.magentocommerce.com/wiki/development/magento_database_diagram or "Apache's OfBiz":https://cwiki.apache.org/confluence/display/OFBTECH/Data+Model+Diagrams.
What you'll see is a flurry of tables working together to provide a flexible schema
on top of a fundamentally inflexible style of database system.

What this means is that the data for any given product is spread out across
dozens of tables. This increases the complexity of the code required to persist
and query individual products and makes a shell-based inqury all but
impossible. Ask yourself if you'd rather write the SQL JOIN to pull together a
product modeled like this:

<div class="clear">
<img src="/assets/content/2010/magento-product-schema.png" />
</div>
<br />

Or issue a simple *find* from the MongoDB JavaScript shell to pull back a JSON
object like this:

<% uv :lang => "javascript", :theme => "twilight" do -%>
{title: "A Love Supreme [Original Recording Reissued]"
 author: "John Coltrane",
 author_id: ObjectID("4bd87bd8277d094c458d2292"),

 details: {
   number_of_discs: 1,
   label: "Impulse Records",
   issue_date: "December 9, 1964",
   average_customer_review: 4.95,
   asin: "B0000A118M"
 },

 pricing: {
  list: 1198,
  retail: 1099,
  savings: 99,
  pct_savings: 8
 },

 category_ids: [
   ObjectID("4bd87bd8277d094c458d2292"),
   ObjectID("4bd87bd8277d094c458d2292"),
   ObjectID("4bd87bd8277d094c458d2292")
 }
}

<% end %>

For object-oriented data, documents make a lot more sense, both
conceptually and performace-wise. A document-oriented representation of product
data means fewer entities (a handful of collections vs. dozens of tables),
better query performance (no server-side joins), and schemas that fit the product
precisely. There's no longer a need to design some master schema that can
account for every single conceviable product.

Catalog management is essentially content management, a domain MongoDB excels at.
To read more about this, see the "Drupal presentation on their move to
MongoDB":http://sf2010.drupal.org/conference/sessions/mongodb-humongous-drupalr.

h2. <strong>Shopping Carts and Orders</strong>

Allowing that a shopping cart is merely an order in a 'cart' state, the
modeling of shopping carts and orders in MongoDB becomes quite straightforward:

<% uv :lang => "javascript", :theme => "twilight" do -%>
{'_id': objectid('4b980a6dea2c3f4579da141e'),
 'user_id': objectid('4b980a6dea2c3f4579a4f54'),
 'state': 'cart',

 'line_items': [
    {'sku': 'jc-432',
     'name': 'John Coltrane: A Love Supreme',
     'retail_price': 4000
    },

    {'sku': 'ly-211',
     'name': 'Larry Young: Unity',
     'retail_price': 9200
    },
  ],

 'shipping_address': {
   'street': '3333 Greene Ave.',
   'city': 'Brooklyn',
   'state': 'NY',
   'zip': '11216'
  },

  'subtotal': 13200,
  'tax':      1100,
  'total':    24200
}
<% end %>

Notice that we can represent the order line items as an array of products. As is
usual with documents, this makes displaying the shopping cart more
straighforward, since no joins are involved. But it also solves the problem of
product versioning. It's often necessary to take a snapshot of a product when a
user purchases it. This can be accomplished in an RDBMS by linking to a
particular version of a product. Here, however, we simply store a snapshot of
the product in the order itself.

h3. <strong>Querying Orders</strong>

Since MongoDB supports dynamic queries and secondary indexes, querying for
orders is a snap. Here, we define an index on product sku, which allows for
efficient queries on all orders of a given product:

<% uv :lang => "javascript", :theme => "twilight" do -%>
db.orders.ensureIndex({'line_items.sku': 1});
db.orders.find({'line_items.sku' => 'jc-431'});
<% end %>

With MongoDB, we can query on arbitrary attributes, so any query on the orders
collection is possible. And for common queries, we can define indexes for
greater efficiency.

<strong>Aggregation</strong><br/>
Of course, aggregation is also necessary. We'll want to report on orders in
different ways, and for that, map-reduce is available. As an example, here's how
to write a map-reduce command that aggregates order totals per zip code:

<% uv :lang => "javascript", :theme => "twilight" do -%>
map = "
  function() {
    emit(this['shipping_address']['zip'], {total: this.total})
  }"

reduce = "
  function(key, values) {
    var sum = 0;
    values.forEach(function(doc) {
      sum += doc.total;
    }

    return {total: sum};
  }"


db.orders.mapReduce(map, reduce, {out: 'order_totals_by_zip'});
<% end %>

For more on MongoDB's map-reduce, see "Map-Reduce Basics":http://kylebanker.com/blog/2009/12/mongodb-map-reduce-basics/.

h3. <strong>Updating Orders</strong>

<strong>Incrementing Quantity</strong><br/>
One way to go about adjusting quantity is using the positional operator, which
lets you apply atomic operation to individual objects within an array. Here,
we're changing the quantity of Coltrane albums we want.

<% uv :lang => "javascript", :theme => "twilight" do -%>
db.orders.update({'_id': order_id, 'line_items.sku':'jc-431'},
                 {'$set': {'line_items.$.quantity': 2}});
<% end %>

<strong>Adding and Removing Items</strong><br/>
Likewise, atomic operators solve the problem of adding and removing products from the cart
For instace, we could use the *$push$ atomic operator to add an item to our cart:

<% uv :lang => "javascript", :theme => "twilight" do -%>
db.orders.update({'_id': order_id},
    {'$push': {'line_items':
      {'sku': 'rrf-334', 'price': 25, 'title': 'Basketball'}}
    });
<% end %>

Both when changing quantity and changing the cart items themselves, it's
necessary to update the order totals. Execution of a server-side JavaScript
function could accomplish this. See "Mike Dirolf's excellent article on the
topic":http://dirolf.com/2010/04/05/stored-javascript-in-mongodb-and-pymongo.html
to see how this could work.

h2. <strong>Inventory</strong>

Not all e-commerce sites need inventory management. But for those that do, MongoDB
can rise to the ocassion.

One way to model inventory is to store a separate document per
physical item in our warehouse. So, for example, if our warehouse has
twenty copies of the Coltrane album, that translates to twenty distinct
documents in our inventory collection. Each document looks something like this:

<% uv :lang => "javascript", :theme => "twilight" do -%>
{'_id': objectid('4b980a6dea2c3f4579da432a'),
 'sku': 'jc-431',
 'state': 'available',
 'expires': null,
 'order_id': null
}
<% end %>

When a user tries to add an item to the cart, a findAndModify command can be
issued to atomically mark the item as in-cart, associate the item with a given
order, and set an expiration time:

<% uv :lang => "javascript", :theme => "twilight" do -%>
query = {'sku': 'jc-431', 'state': 'available'};

update = {'$set':
          {'state':    'cart',
           'order_id': order_id,
           'expires':  Date.now() + 15 * 60}};

item = db.inventory.findAndModify(query: query, update: update);
<% end %>

If we get item back from the findAndModify operation, we know we have a unique lock on that
item, and we can store it in our cart. When the user goes to check out, the
item's state can be advance to 'purchased,' or whatever the case calls for.

Meanwhile, we can run a script in the background that frees cart inventory not
purchased in the fifteen-minutes window. The update is trivial:

<% uv :lang => "javascript", :theme => "twilight" do -%>
db.inventory.update({'state': 'available', 'expires': {'$lt': Date.now()}},
  {'$set' {'state': 'available', 'expires': null, 'order_id': null}},
  false, true);
<% end %>

h2. <strong>Transactions, Consistency, and Durability</strong>

A lot of the arguments levied against MongoDB in <nobr>e-commerce</nobr> center
around transactions, consistency, and durability. A few points, then, are
worth noting.

Concerning transactions, it is true that MongoDB doesn't support multi-object
transactions; however, it does support atomic operations on individual documents. And
this, combined with the document-oriented modeling just described and a little
creativity, is adequate to many e-commerce problems. Certainly, if we needed to
literally debit one account and credit another in the same operation, we'd need
full-fledged transaction. But most e-commerce situations don't require that.

A second important point here is that an API call to authorize a credit card
cannot happen in the scope of a transaction, and yet every e-commerce site
manages this situation. Users often speak of transactions as if they're sacrosanct,
and yet it's possible to handle one of the core activities of an
<nobr>e-commerce</nobr> site without them.

h2. <strong>Conclusion</strong>

Certainly, most NoSQL database weren't build with <nobr>e-commerce</nobr> in
mind. Databases that lack rich data models, dynamic queries, and any notion of
transactionality can't be expected to compete in the <nobr>e-commerce</nobr>
space, and it's understandable how one might think that MongoDB couln't, either.
But this simply isn't the case.

For the parts of an <nobr>e-commerce</nobr> site comprising content management, using
MongoDB will mean a clear win. And even for the more transactional components of the
system, MongoDB has the features necessary to make such compoenets safe
and reliable.

